from dataclasses import asdict
from enum import Enum
from hashlib import sha256
from json import dumps


def json_default(thing):
    # custom serializer for FileType, CombineOp, etc.
    if isinstance(thing, Enum):
        return thing.value
    raise TypeError(f"object of type {type(thing).__name__} not serializable")


def dict_to_sha256(thing):
    # https://death.andgravity.com/stable-hashing
    b = dumps(
        thing,
        default=json_default,
        ensure_ascii=False,
        sort_keys=True,
        indent=None,
        separators=(",", ":"),
    )
    return sha256(b.encode("utf-8")).digest()


def dimindex_to_sha256(di):
    d = asdict(di)
    del d["sequence_len"]  # don't want this in the hash; could change
    return dict_to_sha256(d)


def pattern_blockchain(pattern):
    # this contains general aspects of the file pattern
    # we exclude the file pattern and concat dims because they are generated by iterating
    # if they are generated in a different way, we ultimately don't care
    # The only exception is nitems_per_file...need some way to include that
    root = {
        "fsspec_open_kwargs": pattern.fsspec_open_kwargs,
        "query_string_secrets": pattern.query_string_secrets,
        "file_type": pattern.file_type,
        "is_opendap": pattern.is_opendap,
    }

    root_sha256 = dict_to_sha256(root)

    blockchain = [root_sha256]
    for k, v in pattern.items():
        key_hash = b"".join(sorted([dimindex_to_sha256(dimindex) for dimindex in k]))
        value_hash = sha256(v.encode("utf-8")).digest()
        new_hash = key_hash + value_hash
        new_block = sha256(blockchain[-1] + new_hash).digest()
        blockchain.append(new_block)

    return blockchain


def match_pattern_blockchain(old_pattern_last_hash, new_pattern):

    new_chain = pattern_blockchain(new_pattern)
    for k, h in zip(new_pattern, new_chain):
        if h == old_pattern_last_hash:
            print(f"Found a match for {h.hex()}!")
            return h
